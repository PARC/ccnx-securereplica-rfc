<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.28 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>

<rfc docName="draft-wood-icnrg-securereplica-00" category="std">

  <front>
    <title abbrev="Secure Replica Service in CCN">Secure Replica Service in CCN</title>

    <author initials="M." surname="Mosko" fullname="M. Mosko">
      <organization>PARC</organization>
      <address>
        <email>marc.mosko@parc.com</email>
      </address>
    </author>
    <author initials="C.A." surname="Wood" fullname="Christopher A. Wood">
      <organization>PARC</organization>
      <address>
        <email>christopher.wood@parc.com</email>
      </address>
    </author>

    <date year="2016" month="April" day="03"/>

    <area>General</area>
    <workgroup>icnrg</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>We describe a mechanism for session migration between an authentication endpoint
and content replica in CCN. The technique described herein depends on the CCNx-KE
protocol.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>CCNx-KE is a protocol that enables a consumer and producer to create a session over which
they can communicate securely. Session keys derived from CCNx-KE are used to encrypt
interest and content objects sent between the consumer and producer, as shown below.</t>

<figure><artwork><![CDATA[
+----------+                           +----------+
| Consumer <----(encrypted channel)----> Producer |
+----------+                           +----------+
]]></artwork></figure>

<t>In many cases, the producer must authenticate the consumer before providing any application
data. Moreover, this producer might not be the one storing the data sought after by
the consumer. Therefore, a mechanism to create a secure session between the consumer
and replica is needed to securely obtain data. One way to do this is for the consumer to
create a session with the replica. However, if consumer authentication is performed, then
the replica is burdened with (a) authenticating the consumer and (b) must possess the private
keys necessary to prove its identity to the consumer. A better solution would be to migrate
a session from a producer (authenticator) to a replica (data distributor) securely.</t>

<t>CCNx-KE <xref target="CCNXKE"/> supports the ability to migrate sessions with a MoveToken. However,
the specification does not describe how to create these tokens. In this document, we describe
how to migrate a CCNx-KE session with a particular MoveToken construction.</t>

</section>
<section anchor="assumptions-and-overview" title="Assumptions and Overview">

<t>If a consumer is to migrate a session from a producer to a replica, then the producer
must necessarily trust the replica service to provide the appropriate content. This
trust is based on economics since the producer is likely to pay the replica for its
services. Under this assumption, we also assume that the producer and replica service
can create a secure session amongst themselves. The producer and replica are assumed to be
able to create and share keys on regular basis. We rely on this assumption in the remainder
of the document.</t>

<t>When a client wishes to obtain data from a replica, the following steps occur:</t>

<t><list style="numbers">
  <t>The consumer creates a session with the (authenticating) producer.</t>
  <t>The producer redirects the consumer to the best replica (e.g., based on its geographic location).</t>
  <t>The producer provides the consumer with a MoveToken to use when migrating to the replica.</t>
</list></t>

<t>This is particular exchange in the context of CCNx-KE is outlined below. We will describe
how MoveChallenge, MovePrefix, MoveProof, and MoveToken are created in the following sections.</t>

<figure><artwork><![CDATA[
 Client                 Producer              Replica (MovePrefix)

  (Round 2 Interest)       
  + MoveChallenge          
  +------------------------->

   (Round 2 Content)
  + MovePrefix, MoveToken
  <--------------------------

  (Round 3 Interest)
  + MoveToken, MoveProof
  +---------------------------------------------------->

  (Round 3 Content)
  + NewSessionID
  <----------------------------------------------------+
]]></artwork></figure>

</section>
<section anchor="session-migration" title="Session Migration">

<t>Session keys produced by CCNx-KE are derived from the traffic secret constructed
by the consumer and producer. Therefore, to decrypt traffic from the consumer and join
the session, the MoveToken must allow the replica to extract or recover this secret. Moreover,
since this extraction step must involve some computation, the replica must be allowed
to check that the MoveToken was generated by a trusted producer. This is necessary to avoid
trivial computational Denial of Service (DoS) attacks against the replica.</t>

<t>With the requirements in place, we now describe how to generate the MoveChallenge, MoveProof,
and MoveToken.</t>

<section anchor="movechallenge-and-moveproof" title="MoveChallenge and MoveProof">

<t>The MoveChallenge is as defined in <xref target="CCNXKE"/>. It is a random 256-bit string defined as
follows:</t>

<figure><artwork><![CDATA[
   MoveChallenge = SHA256(X)
]]></artwork></figure>

<t>for a randomly generated 256-bit string X. The value X is also the MoveProof.</t>

</section>
<section anchor="movetoken" title="MoveToken">

<t>The MoveToken must allow the replica to (a) check that the consumer obtained the MoveToken
from a trusted or known producer and (b) extract the traffic secret (TS) to derive the encryption
and decryption keys. Therefore, it is defined as follows</t>

<figure><artwork><![CDATA[
   MoveTokenCT, MoveTokenTag = AEnc(K, MoveChallenge + TS)
   MoveToken = K_id +  MoveTokenCT +  MoveTokenTag
]]></artwork></figure>

<t>where K_id is the key identifier for the key K and + is concatenation. Also, AEnc is
shorthand for authenticated encryption that produces a ciphertext and authentication tag.
One such algorithm is AES-GCM <xref target="GCM"/>.</t>

</section>
<section anchor="verification" title="Verification">

<t>As shown in the protocol diagram above, the consumer must provide both the MoveProof and
MoveToken in the Round 3 Interest (for the desired data). Upon receipt, the replica performs
the following checks:</t>

<t><list style="numbers">
  <t>If K_id is not valid, i.e., the replica has no key with that identifier, then
the Interest is dropped.</t>
  <t>Otherwise, the replica computes</t>
</list></t>

<figure><artwork><![CDATA[
    MoveTokenCT, MoveTokenTag = MoveToken
    MoveChallenge + TS = ADec(K, MoveTokenCT, MoveTokenTag)
]]></artwork></figure>

<t>If the decryption fails, i.e., if the encryption is not valid (the ciphertext was tampered with), then
the Interest is dropped.
3. Otherwise, the replica computes</t>

<figure><artwork><![CDATA[
    Challenge = SHA256(MoveProof)
]]></artwork></figure>

<t>If Challenge = MoveChallenge, then the replica accepts the Interest. Otherwise, the Interest is dropped.</t>

</section>
<section anchor="final-notes" title="Final Notes">

<t>If the traffic secret is recovered correctly, then the replica creates a new SessionID (NewSessionID) for
the session between the replica and consumer and returns it with the corresponding application data requested
in the Round 3 Interest. At this point, both the consumer and replica have a common SessionID and traffic secret
and can then derive the appropriate encryption keys to use when encrypting traffic.</t>

</section>
<section anchor="replica-workload" title="Replica Workload">

<t>To create a new session, the replica must only perform a single authenticated decryption and hash function (SHA256)
computation. No public-key cryptographic algorithms are required to verify a MoveToken and complete the migration.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<t>TODO</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>


<reference anchor="TLS13" target="https://tools.ietf.org/html/draft-ietf-tls-tls13-11">
  <front>
    <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
    <author initials="E." surname="Rescorla">
      <organization>RTFM, Inc.</organization>
    </author>
    <date year="2015" month="December" day="28"/>
  </front>
</reference>
<reference anchor="DTLS12" target="https://tools.ietf.org/html/rfc6347">
  <front>
    <title>Datagram Transport Layer Security Version 1.2</title>
    <author initials="E." surname="Rescorla">
      <organization>RTFM, Inc.</organization>
    </author>
    <author initials="N." surname="Modadugu">
      <organization>Google, Inc.</organization>
    </author>
    <date year="2012" month="January"/>
  </front>
</reference>
<reference anchor="GCM" >
  <front>
    <title>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</title>
    <author initials="M." surname="Dworkin">
      <organization></organization>
    </author>
    <date year="2007" month="November"/>
  </front>
  <seriesInfo name="NIST" value="Special Publication 800-38D"/>
</reference>
<reference anchor="CCNxMessages" target="https://tools.ietf.org/html/draft-irtf-icnrg-ccnxmessages-01">
  <front>
    <title>CCNx Messages in TLV Format</title>
    <author initials="M." surname="Mosko">
      <organization>PARC, Inc.</organization>
    </author>
    <author initials="I." surname="Solis">
      <organization>PARC, Inc.</organization>
    </author>
    <date year="2016" month="January" day="11"/>
  </front>
</reference>
<reference anchor="TLVENCAP" target="https://github.com/PARC/ccnx-tlvencap-rfc">
  <front>
    <title>CCNx Packet Encapsulation</title>
    <author initials="M." surname="Mosko">
      <organization>PARC, Inc.</organization>
    </author>
    <author initials="C." surname="Wood">
      <organization>PARC, Inc.</organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="CCNXKE" target="TODO">
  <front>
    <title>CCNx Key Exchange</title>
    <author initials="M." surname="Mosko">
      <organization>PARC, Inc.</organization>
    </author>
    <author initials="E." surname="Uzun">
      <organization>PARC, Inc.</organization>
    </author>
    <author initials="C.A." surname="Wood">
      <organization>PARC, Inc.</organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>


    </references>

    <references title='Informative References'>





<reference  anchor='RFC5077' target='http://www.rfc-editor.org/info/rfc5077'>
<front>
<title>Transport Layer Security (TLS) Session Resumption without Server-Side State</title>
<author initials='J.' surname='Salowey' fullname='J. Salowey'><organization /></author>
<author initials='H.' surname='Zhou' fullname='H. Zhou'><organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'><organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'><organization /></author>
<date year='2008' month='January' />
<abstract><t>This document describes a mechanism that enables the Transport Layer Security (TLS) server to resume sessions and avoid keeping per-client session state.  The TLS server encapsulates the session state into a ticket and forwards it to the client.  The client can subsequently resume a session using the obtained ticket.  This document obsoletes RFC 4507.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5077'/>
<seriesInfo name='DOI' value='10.17487/RFC5077'/>
</reference>


<reference anchor="HASHCHAIN" >
  <front>
    <title>Password Authentication with Insecure Communication</title>
    <author >
      <organization>L. Lamport</organization>
    </author>
    <date year="1981" month="November"/>
  </front>
  <seriesInfo name="ANSI" value="Communications of the ACM 24.11, pp 770-772"/>
</reference>


    </references>



  </back>
</rfc>

